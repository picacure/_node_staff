// Generated by CoffeeScript 1.6.3
(function() {
  var Blob, Commit, EventEmitter, Gitteh, Index, NativeRemote, NativeRepository, Reference, Refspec, Remote, Repository, Signature, Tag, Tree, args, async, bindings, checkOid, createPrivate, env, fs, getPrivate, immutable, minOidLength, objectTypes, oidRegex, remoteDirs, types, wrapCallback, _path,
    _this = this;

  EventEmitter = require("events").EventEmitter;

  async = require("async");

  fs = require("fs");

  _path = require("path");

  args = require("./args");

  env = "Release";

  bindings = require("../build/" + env + "/gitteh");

  if (env === "Debug") {
    (require("segfault-handler")).registerHandler();
  }

  minOidLength = bindings.minOidLength, types = bindings.types, NativeRepository = bindings.NativeRepository, NativeRemote = bindings.NativeRemote;

  /**
   * @namespace
  */


  Gitteh = module.exports = {};

  /**
   * @ignore
  */


  getPrivate = function(obj) {
    getPrivate.lock++;
    return obj._private;
  };

  getPrivate.lock = 0;

  /**
   * @ignore
  */


  createPrivate = function(obj) {
    var _priv;
    _priv = {};
    Object.defineProperty(obj, "_private", {
      enumerable: false,
      configurable: false,
      get: function() {
        if (!getPrivate.lock--) {
          throw new Error("Bad request");
        }
        return _priv;
      }
    });
    return _priv;
  };

  /**
   * @ignore
  */


  wrapCallback = function(orig, cb) {
    return function(err) {
      if (err != null) {
        return orig(err);
      }
      return cb.apply(null, Array.prototype.slice.call(arguments, 1));
    };
  };

  /**
   * @ignore
  */


  immutable = function(obj, src) {
    var o;
    return o = {
      set: function(name, target) {
        if (target == null) {
          target = name;
        }
        if (Array.isArray(src[name])) {
          Object.defineProperty(obj, target, {
            get: function() {
              return src[name].slice(0);
            },
            configurable: false,
            enumerable: true
          });
          return o;
        }
        Object.defineProperty(obj, target, {
          value: src[name],
          writable: false,
          configurable: false,
          enumerable: true
        });
        return o;
      }
    };
  };

  oidRegex = /^[a-zA-Z0-9]{0,40}$/;

  args.validators.oid = function(val) {
    if (typeof val !== "string") {
      return false;
    }
    if (!oidRegex.test(val)) {
      return false;
    }
    if (val.length < minOidLength) {
      return false;
    }
    return true;
  };

  objectTypes = ["any", "blob", "commit", "tag", "tree"];

  args.validators.objectType = function(val) {
    return objectTypes.indexOf(val > -1);
  };

  remoteDirs = ["push", "fetch"];

  args.validators.remoteDir = function(val) {
    return remoteDirs.indexOf(val > -1);
  };

  checkOid = function(str, allowLookup) {
    if (allowLookup == null) {
      allowLookup = true;
    }
    if (typeof str !== "string") {
      throw new TypeError("OID should be a string");
    }
    if (!oidRegex.test(str)) {
      throw new TypeError("Invalid OID");
    }
    if (str.length < bindings.minOidLength) {
      throw new Error("OID is too short");
    }
    if (!allowLookup && str.length !== 40) {
      throw new TypeError("Invalid OID");
    }
  };

  /**
   * @class
   * Contains the name/email/time for a {@link Commit} author/committer or
   * {@link Tag} tagger.
   * @property {String} name
   * @property {String} email
   * @property {Date} time
   * @property {Integer} offset timezone offset in seconds from GMT.
   * @see Commit
   * @see Tag
  */


  Signature = Gitteh.Signature = function(obj) {
    immutable(this, obj).set("name").set("email").set("time").set("offset");
    return this;
  };

  /**
   * @class
   * Describes the way remote repository references will be mapped to the local
   * repository.
   * @param {String} src
   * @param {String} dst
   * @see Remote
   * @see Reference
  */


  Refspec = Gitteh.Refspec = function(src, dst) {
    var _priv;
    _priv = createPrivate(this);
    _priv.srcRoot = (src != null) && src.slice(-1) === "*" ? src.slice(0, -1) : src;
    _priv.dstRoot = (dst != null) && dst.slice(-1) === "*" ? dst.slice(0, -1) : dst;
    immutable(this, {
      src: src,
      dst: dst
    }).set("src").set("dst");
    return this;
  };

  /**
   * Determines if provided reference name matches source of this Refspec.
   * @param {String} refName
   * @return {Boolean} true if provided refName matches src of Refspec.
  */


  Refspec.prototype.matchesSrc = function(refName) {
    var _priv;
    _priv = getPrivate(this);
    if (refName.length <= _priv.srcRoot.length) {
      return false;
    }
    return refName.indexOf(_priv.srcRoot) === 0;
  };

  /**
   * Determines if provided reference name matches destination of this Refspec.
   * @param {String} refName
   * @return {Boolean} true if provided refName matches dst of Refspec.
  */


  Refspec.prototype.matchesDst = function(refName) {
    var _priv;
    _priv = getPrivate(this);
    if (refName.length <= _priv.dstRoot.length) {
      return false;
    }
    return refName.indexOf(_priv.dstRoot) === 0;
  };

  /**
   * Transforms provided refName to destination, provided it matches src pattern.
   * @param {String} refName
   * @throws {Error} if refName doesn't match src pattern.
   * @return {String} transformed reference name.
  */


  Refspec.prototype.transformTo = function(refName) {
    if (!this.matchesSrc(refName)) {
      throw new Error("Ref doesn't match src.");
    }
    return "" + this.dst.slice(0, -2) + refName.slice(this.src.length - 2);
  };

  /**
   * Transforms provided refName from destination back to source, provided it
   * matches dst pattern. This is the reverse of {@link #transformTo}.
   * @param {String} refName
   * @throws {Error} if refName doesn't match dst pattern.
   * @return {String} (un?)transformed reference name.
  */


  Refspec.prototype.transformFrom = function(refName) {
    if (!this.matchesDst(refName)) {
      throw new Error("Ref doesn't match dst.");
    }
    return "" + this.src.slice(0, -2) + refName.slice(this.dst.length - 2);
  };

  /**
   @class
   * A commit made by a author (and optional different committer), with a message,
   * a {Tree} and zero or more parent {@link Commit} objects.
   * @property {String} id object id of this Commit.
   * @property {String} treeId object id of {@link Tree} for this Commit.
   * @property {Commit[]} parents parent Commits of this Commit (more than one 
   * means a merge-commit).
   * @property {String} message
   * @property {String} messageEncoding
   * @property {Signature} author
   * @property {Signature} committer
  */


  Commit = Gitteh.Commit = function(repository, obj) {
    this.repository = repository;
    obj.author = new Signature(obj.author);
    obj.committer = new Signature(obj.committer);
    immutable(this, obj).set("id").set("tree", "treeId").set("parents").set("message").set("messageEncoding").set("author").set("committer");
    return this;
  };

  /**
   * Fetches the {@link Tree} object for this Commit. Just a convenience method to
   * call out to {@link Repository#tree}(commit.treeId).
   * @param {Function} cb called when Tree has been fetched from repository.
   * @see Tree
  */


  Commit.prototype.tree = function(cb) {
    return this.repository.tree(this.treeId, cb);
  };

  /**
   * @class
   * A Tree contains a list of named entries, which can either be {@link Blob}s or
   * nested {@link Tree}s, each entry is referenced by its oid. A {@link Commit}
   * owns a single {@link Tree}.
   * @property {String} id object id of this Tree.
   * @property {Tree.Entry} entries a list of all entries contained in this Tree.
   * @see Blob
   * @see Commit
  */


  Tree = Gitteh.Tree = function(repository, obj) {
    var entry, origEntry, _i, _len, _ref;
    this.repository = repository;
    obj._entries = obj.entries;
    obj.entries = [];
    _ref = obj._entries;
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      origEntry = _ref[_i];
      obj.entries.push(entry = {});
      immutable(entry, origEntry).set("id").set("name").set("type").set("attributes");
    }
    immutable(this, obj).set("id").set("entries");
    return this;
  };

  /**
   * @class
   * @name Tree.Entry
   * @property {String} id id of object this entry points to.
   * @property {String} name
   * @property {String} type kind of object pointed to by this entry (commit/blob)
   * @property {Integer} attributes UNIX file attributes for this entry.
  */


  /**
   * @class
   * Contains raw data for a file stored in Git.
   * @property {String} id object id of this Blob.
   * @property {Buffer} data Node Buffer containing Blob data.
   * @see Tree
  */


  Blob = Gitteh.Blob = function(repository, obj) {
    this.repository = repository;
    immutable(this, obj).set("id").set("data");
    return this;
  };

  /**
   * @class
   * Git tags are similar to references, and indeed "lightweight" Git tags are 
   * actually implemented as References with a name prefix of "tags/". When 
   * additional metadata is needed (message/name/email/GPG signature), a proper
   * heavyweight Tag object is used.
   * @property {String} id object id of this Tag.
   * @property {String} name
   * @property {String} message
   * @property {Signature} tagger
   * @property {String} targetId object id this Tag points to
   * @property {String} type the type of object this Tag points to.
  */


  Tag = Gitteh.Tag = function(repository, obj) {
    this.repository = repository;
    obj.tagger = new Signature(obj.tagger);
    immutable(this, obj).set("id").set("name").set("message").set("tagger").set("target", "targetId").set("type");
    return this;
  };

  /**
   * Convenience method to get the object this Tag points to. Shorthand for 
   * {@link Repository#object}(tag.targetId)
   * @param {Function} cb called when target object has been loaded.
   * @see Repository#object
  */


  Tag.prototype.target = function(cb) {
    return this.repository.object(this.targetId, this.type, cb);
  };

  /**
   * @class
   * Remotes designate the location and rules of remote Git repositories. Remotes
   * can be obtained by using {@link Repository.remote}.
   * @property {Boolean} connected true if there is an active connection to the
   * Remotes' endpoint.
   * @property {String} name
   * @property {String} url address of Remotes' endpoint
   * @property {Refspec} fetchSpec Refspec used when fetching from Remote
   * @property {Refspec} pushSpec Refspec used when pushing to Remote
   * @property {String} HEAD the remote HEAD reference name (only set after 
   * connected to Remote)
   * @property {String[]} refs names of references on remote (only set after 
   * connected to Remote)
   * @see Repository.remote
  */


  Remote = Gitteh.Remote = function(repository, nativeRemote) {
    var fetchSpec, pushSpec, _priv;
    this.repository = repository;
    _priv = createPrivate(this);
    _priv["native"] = nativeRemote;
    _priv.connected = false;
    if (!(nativeRemote instanceof NativeRemote)) {
      throw new Error("Don't construct me, see Repository.remote()");
    }
    Object.defineProperty(this, "connected", {
      get: function() {
        return _priv.connected;
      },
      enumerable: true,
      configurable: false
    });
    immutable(this, nativeRemote).set("name").set("url");
    fetchSpec = new Refspec(nativeRemote.fetchSpec.src, nativeRemote.fetchSpec.dst);
    pushSpec = new Refspec(nativeRemote.pushSpec.src, nativeRemote.pushSpec.dst);
    immutable(this, {
      fetchSpec: fetchSpec,
      pushSpec: pushSpec
    }).set("fetchSpec").set("pushSpec");
    return this;
  };

  /**
   * Opens a connection to the Remote endpoint. This is needed before 
   * {@link #fetch} or {@link #push} can be called.
   * @param {String} direction The direction of the connection, must be either
   * "push" or "fetch".
   * @param {Function} cb called when connection has been made, or fails.
  */


  Remote.prototype.connect = function() {
    var cb, dir, _priv, _ref,
      _this = this;
    _priv = getPrivate(this);
    _ref = args({
      dir: {
        type: "remoteDir"
      },
      cb: {
        type: "function"
      }
    }), dir = _ref[0], cb = _ref[1];
    dir = dir === "push" ? bindings.GIT_DIR_PUSH : bindings.GIT_DIR_FETCH;
    return _priv["native"].connect(dir, wrapCallback(cb, function(refs) {
      var headOid, headRef, oid, ref, refNames;
      refNames = Object.keys(refs);
      headOid = refs["HEAD"];
      for (ref in refs) {
        oid = refs[ref];
        if (ref === "HEAD") {
          continue;
        }
        if (oid === headOid) {
          headRef = _this.fetchSpec.transformTo(ref);
          immutable(_this, {
            headRef: headRef
          }).set("headRef", "HEAD");
          break;
        }
      }
      immutable(_this, {
        refNames: refNames
      }).set("refNames", "refs");
      _priv.connected = true;
      return cb();
    }));
  };

  /**
   * Fetches Git objects from remote that do not exist locally.
   * @param {Function} progressCb called to notify of progress with fetch process.
   * @param {Function} cb called when fetch has been completed.
  */


  Remote.prototype.fetch = function() {
    var cb, progressCb, update, updateTimer, _priv, _ref,
      _this = this;
    _priv = getPrivate(this);
    if (!this.connected) {
      throw new Error("Remote isn't connected.");
    }
    _ref = args({
      progressCb: {
        type: "function"
      },
      cb: {
        type: "function"
      }
    }), progressCb = _ref[0], cb = _ref[1];
    updateTimer = null;
    update = function() {
      var bytes, done, total, _ref1;
      _ref1 = _priv["native"].stats, bytes = _ref1.bytes, total = _ref1.total, done = _ref1.done;
      progressCb(bytes, total, done);
      return updateTimer = setTimeout(update, 500);
    };
    setTimeout(update, 500);
    return _priv["native"].download(function(err) {
      clearTimeout(updateTimer);
      if (err != null) {
        return cb(err);
      }
      return _priv["native"].updateTips(wrapCallback(cb, function() {
        return cb();
      }));
    });
  };

  /**
   * @class
   * The Git index is used to stage changed files before they are written to the 
   * repository proper. Bindings for the Index are currently minimal.
  */


  Index = Gitteh.Index = function(nativeIndex) {
    var _priv;
    _priv = createPrivate(this);
    _priv["native"] = nativeIndex;
    return this;
  };

  /**
   * Updates the Git index to reflect the state of provided {@link Tree}.
   * @param {String} id object id of Tree to be read.
   * @param {Function} cb called when index update has been completed.
  */


  Index.prototype.readTree = function() {
    var cb, id, _priv, _ref;
    _priv = getPrivate(this);
    _ref = args({
      id: {
        type: "oid"
      },
      cb: {
        type: "function"
      }
    }), id = _ref[0], cb = _ref[1];
    return _priv["native"].readTree(id, cb);
  };

  /**
   * Synchronizes the in-memory Git index with the indexfile located in repository
   * @param {Function} cb called when synchronization is complete.
  */


  Index.prototype.write = function() {
    var cb, _priv;
    _priv = getPrivate(this);
    cb = args({
      cb: {
        type: "function"
      }
    })[0];
    return _priv["native"].write(cb);
  };

  /**
   * @class
   * A Reference is a named pointer to a {@link Commit} object. That is, refs are
   * the DNS of Git-land. References can either be direct or symbolic. Direct 
   * references point to the object id of a commit. Symbolic refs point to other
   * references.
   * @property {String} name
   * @property {Boolean} direct true if Reference points directly to an object id.
   * @property {Boolean} packed true if Reference is in a packfile
   * @property {String} target object id reference points to, or another reference
   * name if not a direct reference.
   * @property {Repository} repository the {@link Repository} that owns this ref.
   * @see Repository#reference
   * @see Repository#createReference
  */


  Reference = Gitteh.Reference = function(repo, nativeRef) {
    var _priv;
    _priv = createPrivate(this);
    _priv["native"] = nativeRef;
    immutable(this, nativeRef).set("name").set("direct").set("packed").set("target");
    immutable(this, {
      repo: repo
    }).set("repo", "repository");
    return this;
  };

  /**
   * @class
   * Represents a local Git repository that has been opened by Gitteh. Used to get
   * access to any objects contained within it.
   * 
   * Repositories can be bare - they will not have a working directory, in this
   * case the contents of what is usually in a .git subdirectory will be in the
   * top level.
   * @property {Boolean} bare true if this repository is bare.
   * @property {String} path location of the Git metadata directory
   * @property {String} workingDirectory location of the working directory, if 
   * applicable (non-bare repository)
   * @property {String[]} remotes  names of remotes configured for this repository
   * @property {String[]} references names of references contained in this 
   * repository.
   * @property {Index} index The Git index for this repository.
  */


  Repository = Gitteh.Repository = function(nativeRepo) {
    var index, _priv;
    if (!(nativeRepo instanceof NativeRepository)) {
      throw new Error("Don't construct me, see gitteh.(open|init)Repository");
    }
    _priv = createPrivate(this);
    _priv["native"] = nativeRepo;
    immutable(this, nativeRepo).set("bare").set("path").set("workDir", "workingDirectory").set("remotes").set("references").set("submodules");
    index = new Index(nativeRepo.index);
    immutable(this, {
      index: index
    }).set("index");
    return this;
  };

  /**
   * Checks if an object with given objectid exists.
   * @param {String} oid ID of object in question.
   * @param {Function} cb Called with status of object existence.
  */


  Repository.prototype.exists = function() {
    var cb, oid, _priv, _ref;
    _priv = getPrivate(this);
    _ref = args({
      oid: {
        type: "oid"
      },
      cb: {
        type: "function"
      }
    }), oid = _ref[0], cb = _ref[1];
    return _priv["native"].exists(oid, cb);
  };

  /**
   * Fetches an object with given ID. The object returned will be a Gitteh wrapper
   * corresponding to the type of Git object fetched. Alternatively, objects with
   * an expected type can be fetched using the {@link #blob}, {@link #commit},
   * {@link #tag}, {@link #tree}, {@link #reference} methods.
   * @param {String} oid id of object to be fetched.
   * @param {Function} cb called when object has been fetched.
   * @see Commit
   * @see Blob
   * @see Tag
   * @see Tree
   * @see Reference
  */


  Repository.prototype.object = function() {
    var cb, oid, type, _priv, _ref,
      _this = this;
    _priv = getPrivate(this);
    _ref = args({
      oid: {
        type: "oid"
      },
      type: {
        type: "objectType",
        "default": "any"
      },
      cb: {
        type: "function"
      }
    }), oid = _ref[0], type = _ref[1], cb = _ref[2];
    return _priv["native"].object(oid, type, wrapCallback(cb, function(object) {
      var clazz;
      clazz = (function() {
        switch (object._type) {
          case types.commit:
            return Commit;
          case types.tree:
            return Tree;
          case types.blob:
            return Blob;
          case types.tag:
            return Tag;
          default:
            return void 0;
        }
      })();
      if (clazz === void 0) {
        return cb(new TypeError("Unexpected object type"));
      }
      return cb(null, new clazz(_this, object));
    }));
  };

  /**
   * Fetches a {@link Blob} object from the repository. This is a stricter
   * variant of {@link #object} - an error will be thrown if object isnt a blob.
   * @param {String} oid id of blob to be fetched.
   * @param {Function} cb called when blob has been fetched.
   * @see #object
  */


  Repository.prototype.blob = function(oid, cb) {
    return this.object(oid, "blob", cb);
  };

  /**
   * Fetches a {@link Commit} object from the repository. This is a stricter
   * variant of {@link #object} - an error will be thrown if object isnt a commit.
   * @param {String} oid id of commit to be fetched.
   * @param {Function} cb called when commit has been fetched.
   * @see #object
  */


  Repository.prototype.commit = function(oid, cb) {
    return this.object(oid, "commit", cb);
  };

  /**
   * Fetches a {@link Tag} object from the repository. This is a stricter
   * variant of {@link #object} - an error will be thrown if object isnt a tag.
   * @param {String} oid id of tag to be fetched.
   * @param {Function} cb called when tag has been fetched.
   * @see #object
  */


  Repository.prototype.tag = function(oid, cb) {
    return this.object(oid, "tag", cb);
  };

  /**
   * Fetches a {@link Tree} object from the repository. This is a stricter
   * variant of {@link #object} - an error will be thrown if object isnt a tree.
   * @param {String} oid id of tree to be fetched.
   * @param {Function} cb called when tree has been fetched.
   * @see #object
  */


  Repository.prototype.tree = function(oid, cb) {
    return this.object(oid, "tree", cb);
  };

  /**
   * Fetches a {@link Reference} object from the repository. This is a stricter 
   * variant of {@link #object} - an error will be thrown if object isnt a ref.
   * @param {String} oid id of reference to be fetched.
   * @param {Function} cb called when reference has been fetched.
   * @see #object
  */


  Repository.prototype.reference = function() {
    var cb, name, resolve, _priv, _ref,
      _this = this;
    _priv = getPrivate(this);
    _ref = args({
      name: {
        type: "string"
      },
      resolve: {
        type: "bool",
        "default": false
      },
      cb: {
        type: "function"
      }
    }), name = _ref[0], resolve = _ref[1], cb = _ref[2];
    return _priv["native"].reference(name, resolve, wrapCallback(cb, function(ref) {
      return cb(null, new Reference(_this, ref));
    }));
  };

  /**
   * Alias of {@link #reference}.
   * @param {String} oid id of reference to be fetched.
   * @param {Function} cb called when reference has been fetched.
   * @see #reference
  */


  Repository.prototype.ref = Repository.prototype.reference;

  /**
   * Creates a new reference, which can either by direct or symbolic.
   * @param {String} name
   * @param {String} target reference/oid targetted by the new reference.
   * @param {Boolean} [force=false] force creation of this reference, destroying 
   * the reference with same name, if it exists.
   * @param {Function} cb called when reference has been created.
   * @see Reference
  */


  Repository.prototype.createReference = function() {
    var cb, fn, force, name, target, _priv, _ref,
      _this = this;
    _priv = getPrivate(this);
    _ref = args({
      name: {
        type: "string"
      },
      target: {
        type: "string"
      },
      force: {
        type: "bool",
        "default": false
      },
      cb: {
        type: "function"
      }
    }), name = _ref[0], target = _ref[1], force = _ref[2], cb = _ref[3];
    fn = "createSymReference";
    if (target.length === 40 && oidRegex.test(target)) {
      fn = "createOidReference";
    }
    return _priv["native"][fn](name, target, force, wrapCallback(cb, function(ref) {
      return cb(null, new Reference(_this, ref));
    }));
  };

  /**
   * Loads a remote with given name.
   * @param {String} name
   * @param {Function} cb called when remote has been loaded.
  */


  Repository.prototype.remote = function() {
    var cb, name, _priv, _ref,
      _this = this;
    _priv = getPrivate(this);
    _ref = args({
      name: {
        type: "string"
      },
      cb: {
        type: "function"
      }
    }), name = _ref[0], cb = _ref[1];
    return _priv["native"].remote(name, wrapCallback(cb, function(remote) {
      return cb(null, new Remote(_this, remote));
    }));
  };

  /**
   * Create a new {@link Remote} for this repository.
   * @param {String} name
   * @param {String} url 
   * @param {Function} cb called when Remote has been created.
   * @see Remote
  */


  Repository.prototype.createRemote = function() {
    var cb, name, url, _priv, _ref,
      _this = this;
    _priv = getPrivate(this);
    _ref = args({
      name: {
        type: "string"
      },
      url: {
        type: "string"
      },
      cb: {
        type: "function"
      }
    }), name = _ref[0], url = _ref[1], cb = _ref[2];
    return _priv["native"].createRemote(name, url, wrapCallback(cb, function(remote) {
      return cb(null, new Remote(_this, remote));
    }));
  };

  /**
   * Opens a local Git repository.
   * @param {String} path The path to the local git repo.
   * @param {Function} cb Called when {@link Repository} has opened.
   * @see Repository
  */


  Gitteh.openRepository = function() {
    var cb, path, _ref;
    _ref = args({
      path: {
        type: "string"
      },
      cb: {
        type: "function"
      }
    }), path = _ref[0], cb = _ref[1];
    return bindings.openRepository(path, wrapCallback(cb, function(repo) {
      return cb(null, new Repository(repo));
    }));
  };

  /**
   * @param {String} path Path where new Git repository should be created.
   * @param {Boolean} [bare=false] When true creates a bare repo. Bare repositories 
   have no working directory.
   * @param {Function} cb Called when {@link Repository} has been created.
   * Creates a new local Git repository.
  */


  Gitteh.initRepository = function() {
    var bare, cb, path, _ref;
    _ref = args({
      path: {
        type: "string"
      },
      bare: {
        type: "bool",
        "default": false
      },
      cb: {
        type: "function"
      }
    }), path = _ref[0], bare = _ref[1], cb = _ref[2];
    return bindings.initRepository(path, bare, wrapCallback(cb, function(repo) {
      return cb(null, new Repository(repo));
    }));
  };

  /**
   * Clones a remote Git repository to the local machine. Currently, only HTTP/Git
   * protocols are supported (no git+ssh yet).
   * @param {String} url Address of remote Git repository.
   * @param {String} path Destination path for cloned repository.
  */


  Gitteh.clone = function() {
    var cb, emitter, path, url, _ref;
    _ref = args({
      url: {
        type: "string"
      },
      path: {
        type: "string"
      }
    }), url = _ref[0], path = _ref[1], cb = _ref[2];
    emitter = new EventEmitter;
    async.waterfall([
      function(cb) {
        return Gitteh.initRepository(path, false, cb);
      }, function(repo, cb) {
        return repo.createRemote("origin", url, wrapCallback(cb, function(remote) {
          return cb(null, repo, remote);
        }));
      }, function(repo, remote, cb) {
        return remote.connect("fetch", wrapCallback(cb, function() {
          return cb(null, repo, remote);
        }));
      }, function(repo, remote, cb) {
        var emitProgress;
        emitProgress = function(bytes, done, complete) {
          return emitter.emit("status", bytes, done, complete);
        };
        return remote.fetch(emitProgress, wrapCallback(cb, function() {
          return cb(null, repo, remote);
        }));
      }, function(repo, remote, cb) {
        return repo.ref(remote.HEAD, true, wrapCallback(cb, function(ref) {
          return cb(null, repo, remote, ref);
        }));
      }, function(repo, remote, headRef, cb) {
        var refName;
        refName = remote.fetchSpec.transformFrom(remote.HEAD);
        return repo.createReference(refName, headRef.target, wrapCallback(cb, function() {
          return cb(null, repo, remote, headRef);
        }));
      }, function(repo, remote, headRef, cb) {
        return repo.commit(headRef.target, wrapCallback(cb, function(commit) {
          return cb(null, repo, remote, commit);
        }));
      }, function(repo, remote, headCommit, cb) {
        return headCommit.tree(wrapCallback(cb, function(tree) {
          return cb(null, repo, remote, tree);
        }));
      }, function(repo, remote, headTree, cb) {
        var checkoutTree, handleEntry;
        handleEntry = function(dest, entry, cb) {
          var subPath;
          if (entry.type === "tree") {
            subPath = _path.join(dest, entry.name);
            return async.series([
              function(cb) {
                return fs.mkdir(subPath, cb);
              }, function(cb) {
                return repo.tree(entry.id, wrapCallback(cb, function(subtree) {
                  return checkoutTree(subtree, subPath, cb);
                }));
              }
            ], cb);
          } else if (entry.type === "blob") {
            return repo.blob(entry.id, wrapCallback(cb, function(blob) {
              var file;
              file = fs.createWriteStream(_path.join(dest, entry.name), {
                mode: entry.attributes
              });
              file.write(blob.data);
              file.end();
              return cb();
            }));
          } else {
            return cb();
          }
        };
        checkoutTree = function(tree, dest, cb) {
          return async.forEach(tree.entries, handleEntry.bind(null, dest), cb);
        };
        return checkoutTree(headTree, repo.workingDirectory, wrapCallback(cb, function() {
          return cb(null, repo, remote, headTree);
        }));
      }, function(repo, remote, headTree, cb) {
        return repo.index.readTree(headTree.id, wrapCallback(cb, function() {
          return cb(null, repo, remote);
        }));
      }, function(repo, remote, cb) {
        return repo.index.write(wrapCallback(cb, function() {
          return cb(null, repo, remote);
        }));
      }
    ], function(err, repo) {
      if (err != null) {
        return emitter.emit("error", err);
      }
      return emitter.emit("complete", repo);
    });
    return emitter;
  };

}).call(this);
